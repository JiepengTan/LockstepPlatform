//#define CHECKBINARYSERIALIZER //开启纯泛型接口错误检测

using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace BinarySerializer {
    public static partial class BinarySerializer {
        public interface ISerilizerBase {
            void Write(System.IO.BinaryWriter stream, object val);
            object Read(byte[] fieldData, ref int cursor);
        }

        class FuncWrap<T> : ISerilizerBase {
            private FuncRead<T> readFunc;
            private FuncWrite<T> writeFunc;

            public FuncWrap(FuncRead<T> readFunc, FuncWrite<T> writeFunc){
                this.readFunc = readFunc;
                this.writeFunc = writeFunc;
            }

            public void Write(System.IO.BinaryWriter stream, object val){
                writeFunc(stream, (T) val);
            }

            public object Read(byte[] fieldData, ref int cursor){
                return readFunc(fieldData, ref cursor);
            }
        }

        static class _WriteHelper<T> {
            internal static FuncWrite<T> Fun;

            internal static void Call(System.IO.BinaryWriter stream, T val){
#if DEBUG || CHECKBINARYSERIALIZER
                if (Fun == null) {
                    Debug.LogError("WriteHelper Error : Did not support that kind of type " + typeof(T).ToString());
                    return;
                }
#endif
                Fun(stream, val);
            }
        }

        static class _ReadHelper<T> {
            internal static FuncRead<T> Fun;

            internal static T Call(byte[] fieldData, ref int cursor){
#if DEBUG || CHECKBINARYSERIALIZER
                if (Fun == null) {
                    Debug.LogError("ReadHelper Error : Did not support that kind of type " + typeof(T).ToString());
                }
#endif
                return Fun(fieldData, ref cursor);
            }
        }

        static BinarySerializer(){
            allSerializers.Clear();
            RegisterInnerTypes();
            RegisterExtensionTypes();
            RegisterAutoGeneratedTypes();
        }


        static Dictionary<Type, ISerilizerBase> allSerializers = new Dictionary<Type, ISerilizerBase>();
        static HashSet<Type> innerTypes;

        delegate T FuncRead<T>(byte[] fieldData, ref int cursor);

        delegate void FuncWrite<T>(System.IO.BinaryWriter stream, T val);

        static FuncRead<T> GetReadFunc<T>(){
            return _ReadHelper<T>.Fun;
        }

        static FuncWrite<T> GetWriteFunc<T>(){
            return _WriteHelper<T>.Fun;
        }

        public static bool IsBasicType(Type t){
            return innerTypes.Contains(t);
        }

        static void RegisterInnerTypes(){
            RegisterInnerReaderWriter(ReadSingle, WriteSingle);
            RegisterInnerReaderWriter(ReadBoolean, WriteBoolean);
            RegisterInnerReaderWriter(ReadString, WriteString);
            RegisterInnerReaderWriter(ReadByte, WriteByte);
            RegisterInnerReaderWriter(ReadInt16, WriteInt16);
            RegisterInnerReaderWriter(ReadInt32, WriteInt32);
            RegisterInnerReaderWriter(ReadInt64, WriteInt64);
            RegisterInnerReaderWriter(ReadUInt16, WriteUInt16);
            RegisterInnerReaderWriter(ReadUInt32, WriteUInt32);
            RegisterInnerReaderWriter(ReadUInt64, WriteUInt64);
            RegisterInnerReaderWriter(ReadVector2, WriteVector2);
            RegisterInnerReaderWriter(ReadVector3, WriteVector3);
            RegisterInnerReaderWriter(ReadVector2Int, WriteVector2Int);
            RegisterInnerReaderWriter(ReadVector3Int, WriteVector3Int);
            RegisterInnerReaderWriter(ReadColor, WriteColor);
        }

        static void RegisterInnerReaderWriter<T>(FuncRead<T> readFunc, FuncWrite<T> writeFunc){
            innerTypes.Add(typeof(T));
            RegisterReaderWriter(readFunc, writeFunc);
        }

        static void RegisterReaderWriter<T>(FuncRead<T> readFunc, FuncWrite<T> writeFunc){
            _WriteHelper<T>.Fun = writeFunc;
            _ReadHelper<T>.Fun = readFunc;
            allSerializers.Add(typeof(T), new FuncWrap<T>(readFunc, writeFunc));
        }
    }
}