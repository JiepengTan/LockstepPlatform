using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Entitas;
using Lockstep.Serialization;
using Debug = Lockstep.Logging.Debug;

namespace Lockstep.CodeGenerator {

    public partial class EditorCodeGeneratorExtensionEcs : EditorBaseCodeGenerator {
        public override string prefix {
            get { return "\t\t\t"; }
        }

        protected override void ReflectRegisterTypes(){
            Type[] types = null;
            HashSet<Type> allTypes = new HashSet<Type>();
            types = GetTypes();
            var interfaceName = GenInfo.InterfaceName;
            foreach (var t in types) {
                if (!allTypes.Add(t)) continue;
                if (t.GetCustomAttributes(typeof(Entitas.CodeGeneration.Attributes.DontGenerateAttribute),
                    true).Any()) {
                    continue;
                }
                if (t.IsSubclassOf(typeof(BaseFormater)) 
                    &&t.GetCustomAttribute(typeof(SelfImplementAttribute)) == null
                ) {
                    var allInterfaces = t.GetInterfaces();
                    var interfaces = allInterfaces.Where((_t) => _t.FullName.Contains(interfaceName)).ToArray();
                    if (interfaces.Length > 0) {
                        RegisterType(t);
                    }
                }
            }
        }

        public override void GenerateCodeNodeData(bool isRefresh, params Type[] types){
            var ser = new CodeGenerator();
            var extensionStr = GenTypeCode(ser,new TypeHandlerECS(this));
            var registerStr = GenRegisterCode(ser);
            var finalStr = GenFinalCodes(extensionStr, registerStr, isRefresh);
            SaveFile(isRefresh, finalStr);
        }

        protected string GenRegisterCode(CodeGenerator gen){
            var allGentedTypes = gen.AllGeneratedTypes;
            var prefix = "";
            var RegisterType = "{0}namespace {2}{{public partial class {1} : BaseComponent{{}}}};";
            allGentedTypes.Sort((a, b) => { return GetTypeName(a).CompareTo(GetTypeName(b)); });
            StringBuilder sb = new StringBuilder();
            foreach (var t in allGentedTypes) {
                var clsFuncName = GetTypeName(t);
                var nameSpace = GetNameSpace(t);
                sb.AppendLine(string.Format(RegisterType, prefix, clsFuncName, nameSpace));
            }

            return sb.ToString();
        }

        string GenFinalCodes(string extensionStr, string RegisterStr, bool isRefresh){
            string fileContent =
                @"//#define DONT_USE_GENERATE_CODE 
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Lockstep.CodeGenerator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//     https://github.com/JiepengTan/LockstepPlatform
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using Lockstep.Serialization;
//#DECLARE_BASE_TYPES

#if !DONT_USE_GENERATE_CODE
//#TYPES_EXTENSIONS
#endif
";
            return fileContent
                    .Replace("//#DECLARE_BASE_TYPES", RegisterStr)
                    .Replace("//#TYPES_EXTENSIONS", extensionStr)
                ;
        }
    }
}